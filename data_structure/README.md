<center>자료구조와 알고리즘  </center>

# 1. 서론
> ※ 완벽한 자료구조는 없고, 각각의 장단점이 있기 때문에, 상황에 맞게 쓸 필요가 있다.  
> 　 공부할 때, **이 때는 왜 이 자료구조를 쓰는지**에 초점을 맞출 것

**자료 구조**(Data Structure): 효율적인 데이터 형태
- 단순 자료구조
- 선형 자료구조(List, Stack, ...): 한 줄로 이루어진 데이터 모음
- 비선형 자료구조(Tree, Graph, ...): 한 데이터에 여러 개가 연결된 형태
- 파일 자료구조: 파일을 저장하는 방식
  - 순차 파일(Sequential File): 파일을 순차적으로 저장
    - 공간 효율 ↑
    - 끝에 추가하기는 좋지만, 중간에 끼워넣거나 중간에 있는 데이터를 빼기는 어려움  

  - 직접 파일(Direct File): 파일을 랜덤한(Hash 함수로 계산된) 자리에 저장
    - 공간 효율 ↓

  - 색인 순차 파일(Indexed Sequential File): 둘을 섞은 것

---

**알고리즘**(Algorithm): 주어진 문제를 해결하는 논리적인 절차  
- 표현법
  - 순서도
  - 의사코드(Psuedo Code)
    특정 언어로 코드를 짜는 경우, 그 언어 특성에 영향을 많이 받기 때문에 고려할 만하다.

- 성능
  - 시간 효율(얼마나 빠른가) → 시간 복잡도(Time Complexity)
    빅-오 표기법[O(~\~)]: 최악의 경우 하게 되는 연산 횟수를 표시("차원"에 대한 이야기이므로, 상수 배는 생각하지 않는다.)
    *ex) O(n^2^) → 입력받은 데이터가 n이면, 연산 횟수는 n의 제곱에 비례한다.*
      
    ※ 주의: 빅-오 표기법에서 쓰는 로그는 밑이 2이다(상용로그가 아님/생각해보니 로그의 밑은 별 의미가 없다.)

# 2. 선형 자료 구조
## 2. 1. 선형 리스트

- 연속된 공간에 붙어 있는 리스트
- python의 리스트, Java 등의 배열이 여기 포함
- 중간에 데이터가 들어오거나 나갈 때, 순차적으로 당겨 와야 한다. → O(n) 만큼의 시간 복잡도를 갖는다.
  - 중간에 삽입  
    A, B, D → A, B, D, ( ) → A, B, ( ), D → A, B, C, D  
    
  - 중간에 있던 데이터를 삭제  
    A, B, X, C, D → A, B, ( ), C, D → A, B, C, ( ), D →  
    A, B, C, D, ( ) → A, B, C, D
  
  (끝에서 추가/제거가 이루어지면 연산을 1번만 해도 된다.)

## 2. 2. 단순 연결 리스트

- 연속되지 않고 떨어진 공간에 있는 리스트
  다음 자료가 어디 있는지의 정보를 저장함으로써 접근한다.  

- 특징
  - 중간에 데이터를 삽입/삭제를 해도 주변 데이터만 수정하면 되기 때문에 빠르다.
    
  - 서로 멀리 떨어져있기 때문에 탐색은 느리다.  
  
    → **중간에 데이터를 끼워넣는 일이 많을 때** 쓴다.

- 사용법  
  헷갈리면 그림 그린 후 할 것
  - 데이터 삽입 (n번째 자리에 넣고 싶다면...)
    > ```py
    > # a. 넣고 싶은 자리 바로 직전 자리를 찾아 저장한다.
    > pre = head
    > while pre.data != target:
    >   pre = pre.link
    > 
    > # b. 그 다음 노드도 임시 변수에 저장한다.
    > post = pre.link
    > 
    > # c. 새로운 노드를 만들어서 저장한다. 이러면 끼워넣을 노드와 양 옆 노드, 총 3개가 저장된다.
    > new_node = Node()
    > 
    > # d. 이제 pre - new_node - post 순으로 링크해준다. 
    > pre.link = new_node
    > new_node.link = post
    > ```
    1. _"처음(head)이 아닌 경우만"_ 저장할 자리 왼쪽의 노드(pre)를 저장한다.
    2. _"마지막이 아닌 경우만"_ 저장할 자리 오른쪽의 노드(post)를 저장한다.
    3. 새로운 노드(new_node)를 만들어서 저장한다.
    4. 이 3개를 연결하면 된다.

## 2. 3. 원형 <a id=talmo href='javascript:document.getElementById("talmo").innerText="탈모";'>연결</a> 리스트
  ~~원형탈모~~
- 단순 연결 리스트에서 양 끝이 연결된 것 (끝이 없다.)

## 2. 4. 스택(Stack)
- Last in, First out  
깊이 우선 탐색..?

- 기능/속성
  - push(data)  
    끝에 data를 넣는다.
  - pop()  
    끝에 있는 data를 뺀다.
  - peek()
    끝에 있는 data를 확인만 한다.  
  - top
    현재 데이터가 있는 위치(없으면 -1)

→ 원리 자체는 간단하므로, 어디에 쓸지 생각해볼 것. 

## 2. 5. 큐(Queue)
- 기능/속성
  - enQueue(data)  
    끝에 data를 넣는다. 끝에 넣었으므로, rear 값이 하나 늘어난다.
  - deQueue()  
    앞의 데이터를 뺀다. 앞을 뺐으므로, front 값이 하나 늘어난다.
  - front, rear (시작 값 = -1)  
    데이터가 _시작하기 직전(빈칸이 끝나는)_ 위치, 끝나는 위치  

  (이렇게 되면 rear가 계속 밀려서 끝까지 가버리는데, 이 경우 데이터를 앞으로 땡겨온다.)

### 2. 5. 1 원형 큐
  
데이터를 당겨오는 과정에서 오버헤드 발생
→ 데이터를 당겨오지 않는 대안 필요  
(rear가 끝으로 가버려도 자료롤 옮기지 않고, 다시 rear를 0번으로 보낸다.)
- 특징  
  한 칸을 버린다.
- 일반 큐와의 차이점
  - isEmpty 연산
    front == rear 인 경우 비어있는 것으로 본다.
  - isFull 연산  
    한 칸만 비어있는 경우(rear 다음 칸이 front인 경우), 가득 찬 것으로 본다.  
    rear + 1 == front (front가 0이 아닌 경우)  
    rear + 1 == 0 (front가 0인 경우)<br><br>
    이대로 쓰자니 연산이 복잡해서, (rear + 1) % size == front 로 줄여 쓴다.

# 3. 비선형 자료구조
## 3. 1. 이진 트리

- **트리(Tree)**: 근원(root) 에서 뻗어나가는 데이터 형태
  - 용어
    - 노드(Node): 각각의 위치
    - 에지(Edge): 노드 간의 연결 (트리에서의 연결은 부모-자식 관계를 의미한다.)
    - 차수(Degree): 자식 노드의 개수 (없는 노드를 리프(Leaf)라고 부른다.)
    - 루트(Root): 트리의 시작 노드
      (루트 기준 왼쪽을 왼쪽 서브트리, 오른쪽을 오른쪽 서브트리라 한다.)
    - 레벨(Level): 루트에서 몇 번 내려가야 있는가
    - 높이(Height): 레벨의 최댓값
  
  
- **이진 트리**(Binary Tree): 모든 노드의 차수가 2 이하인 트리  
  (이진 트리는 상대적으로 데이터를 다루기 편한가 봄. 일진 트리는 그냥 연결 리스트.)
  - 종류
    - 포화 이진 트리: 마지막 레벨을 제외한 모든 노드의 차수가 2인 트리 (토너먼트 대진표 모양)
    - 완전 이진 트리: 왼쪽에서 오른쪽으로 번호를 매겼을 때, 빠지는 번호가 없는 트리
    - 편향 이진 트리: 왼쪽/오른쪽 중 한 쪽으로만 뻗은 트리
    - 일반 이진 트리: 해당 사항 없는 이진 트리
    

  - 순회(traversal)  
  "데이터를 언제 처리하느냐" 에 따라 결정
    - 전위 순회(preorder traversal)
      - 자기 자신을 처리
      - 자기 자신의 왼쪽을 전부 처리
      - 자기 자신의 오른쪽을 전부 처리

    - 중위 순회(inorder traversal)
      - 자기 자신의 왼쪽을 전부 처리
      - 자기 자신을 처리
      - 자기 자신의 오른쪽을 전부 처리
        
    - 후위 순회(postorder traversal)
      - 자기 자신의 왼쪽을 전부 처리
      - 자기 자신의 오른쪽을 전부 처리
      - 자기 자신을 처리
  
- **이진 탐색 트리**(Binary Search Tree): 데이터의 크기(정수 실수 등등)에 따라 구성한 이진 트리
  - 값 탐색 시 배열보다 훨씬 더 빠르다. 시간 복잡도 N(n) → N(log N)
  - 규칙
    - 왼쪽 서브 트리 값들 < 루트 값 < 오른쪽 서브 트리 값들 (중복 값은 들어가지 않는다.)
    - 모든 서브 트리들도 같은 규칙 적용
    
    → 내 왼쪽은 작은 것들, 오른쪽은 큰 것들만 모인 것
  - 삽입/삭제
    - 삽입  
      - 변수를 하나 만들고 루트를 할당한다.
      - 넣을 값이 변수(노드) 보다 작으면 왼쪽, 높으면 오른쪽으로 이동한다.
      - 위 과정을 왼쪽, 오른쪽이 없을 때까지 반복한다.
      - 자리에 넣는다.
    - 삭제
      - 리프의 경우, 부모 노드와의 연결을 끊고 삭제하면 된다.
      - 자식이 하나 있으면, 부모 노드를 자식과 이어주고 삭제하면 된다.
      - 두 개면 나도 몰라